# Test Data:
```
INSERT INTO product (name, price) VALUES
('iPhone', 100),
('Headphones', 20),
('Case', 10),
('Charger', 15),
('Backpack', 50),
('Sunglasses', 60),
('Book', 10),
('Water Bottle', 8),
('Desk Lamp', 35);

INSERT INTO coupon (code, discount_type, discount_value) VALUES
('D15', 'percent', 15),
('FIX10', 'fixed', 10),
('SUMMER20', 'percent', 20),
('WELCOME5', 'fixed', 5),
('BLACKFRIDAY', 'percent', 30),
('STUDENT10', 'fixed', 10),
('NEWYEAR20', 'percent', 20),
('EASTER5', 'fixed', 5),
('FLASHSALE', 'percent', 25),
('WEEKEND10', 'fixed', 10),
('DISCOUNT15', 'percent', 15),
('CLEARANCE', 'fixed', 20);

INSERT INTO tax (country, rate) VALUES
('DE', 19),
('IT', 22),
('FR', 20),
('GR', 24);

INSERT INTO order (product_id, tax_number, coupon_code, payment_processor, total_price) VALUES
(1, 'DE123456789', 'D15', 'paypal', 116),
(3, 'IT987654321', 'FIX10', 'credit_card', 22),
(2, 'FR123456789', 'SUMMER20', 'paypal', 19.2),
(5, 'GR123456789', 'WELCOME5', 'stripe', 6);
```

# Написать Symfony REST приложение для расчета цены продукта и проведения оплаты

Необходимо написать 2 эндпоинта:
1. POST: для расчёта цены
   
http://127.0.0.1:80/calculate-price

Пример json тела запроса:
```
{
    "product": 1,
    "taxNumber": "DE123456789",
    "couponCode": "D15"
}
```
2. POST: для выполнения покупки
   
http://127.0.0.1:80/purchase

Пример json тела запроса:
```
{
    "product": 1,
    "taxNumber": "IT12345678900",
    "couponCode": "D15",
    "paymentProcessor": "paypal"
}
```

При успешном выполнении запроса вернуть HTTP ответ с кодом 200.

При неверных входных данных или ошибках оплаты вернуть HTTP ответ с кодом 400 и json объект с ошибками.

## Продукты
- Iphone (100 евро)
- Наушники (20 евро)
- Чехол (10 евро)

## Купоны
При наличии купона покупатель может применить его к покупке.  
Купон может быть двух типов:
- фиксированная сумма скидки
- процент от суммы покупки

## Расчет налога
При покупке продукта получатель сверх цены продукта должен уплатить налог, относительно страны налогового номера:
- Германии - 19%
- Италии - 22%
- Франции - 20%
- Греции - 24%

В итоге для покупателя Iphone из Греции цена составляет 124 евро (цена продукта 100 евро + налог 24%).  
Если у покупателя есть купон на 6% скидку на покупку, то цена будет 116.56 евро (цена продукта 100 евро - 6% скидка + налог 24%).

## Формат налогового номера
DEXXXXXXXXX - для жителей Германии,

ITXXXXXXXXXXX - для жителей Италии,

GRXXXXXXXXX - для жителей Греции,

FRYYXXXXXXXXX - для жителей Франции

где: 
- первые два символа - это код страны,
- X - любая цифра от 0 до 9,
- Y - любая буква

Обратите внимание, что длина налогового номера разная для разных стран.  
Форматы налоговых номеров могут меняться, что случается редко. (Это зависит от законодательства.)

## Детали
При выполнении задания нужно:
- реализовать валидацию всех полей (в том числе корректность tax номера согласно формату) в теле запросов, используя Symfony validator
- рассчитать итоговую цену покупки вместе с купоном (если указан) и налогом
- использовать для проведения платежа `PaypalPaymentProcessor::pay()` или `StripePaymentProcessor::processPayment()`  
Эти классы представлены в этом проекте, использовать следует именно их. В методах оплаты они принимают цену как в разных юнитах (как в центах, так и в долларах).
    - ИЛИ скопируйте их себе в проект. Для простоты представьте, что эти два класса входят в два разных сторонних SDK, и у вас **нет возможности править эти классы или какую-либо логику внутри них**.
    - ИЛИ добавьте `systemeio/test-for-candidates` как зависимость через Composer.
- приложить в README.md примеры HTTP-запросов к двум эндпоинтам: path и тело запроса (для ручного тестирования) в формате curl команды

CRUD для сущностей писать не нужно.

При написании тестового используйте git, после выполнения пришлите ссылку на репозиторий.

Необходимо учесть возможность добавления новых PaymentProcessors.

### Будет плюсом
- использование контейнеризации для php, postgres/mysql
- наличие PHPUnit tests
- соответствие кода принципам SOLID (без фанатизма)
- покоммитное оформление этапов реализации приветствуется
- продемонстрированное умение **НЕ!** использовать подходы вроде onion-based/DDD/CQS/гексагональной архитектуры при выполнении задания: мы куда больше ценим его корректность и полноту; такие сложные концепции в нашем задании скорее не уместны

Мы не ограничиваем вас по срокам выполнения задания, но при этом ожидаем, что в тестовом задании вы раскроете принципы, которых придерживаетесь в работе. 
